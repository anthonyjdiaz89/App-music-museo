/**
 * Generate Assets for Expo Mobile App
 * Copies covers and audio from admin panel uploads to app assets directory
 * Generates TypeScript map files and library.json for offline usage
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT = path.resolve(__dirname, '..');
const DATA_DIR = path.join(ROOT, 'data');
const UPLOADS_DIR = path.join(ROOT, 'uploads');
const AUDIO_DIR = path.join(UPLOADS_DIR, 'audio');
const COVERS_DIR = path.join(UPLOADS_DIR, 'covers');

const APP_ROOT = path.resolve(ROOT, '..', 'app-museo-vallenato');
const APP_ASSETS = path.join(APP_ROOT, 'assets');
const APP_COVERS = path.join(APP_ASSETS, 'covers');
const APP_AUDIO = path.join(APP_ASSETS, 'audio');
const APP_DATA = path.join(APP_ASSETS, 'data');

const APP_PUBLIC = path.join(APP_ROOT, 'public');
const APP_PUBLIC_ASSETS = path.join(APP_PUBLIC, 'assets');
const APP_PUBLIC_COVERS = path.join(APP_PUBLIC_ASSETS, 'covers');
const APP_PUBLIC_AUDIO = path.join(APP_PUBLIC_ASSETS, 'audio');

const ENCODING_REPLACEMENTS = [
  [/Ã¡/g, 'a'], [/Ã©/g, 'e'], [/Ã­/g, 'i'], [/Ã³/g, 'o'], [/Ãº/g, 'u'],
  [/Ã±/g, 'n'], [/Ã/g, 'A'], [/Ã/g, 'E'], [/Ã/g, 'I'], [/Ã/g, 'O'],
  [/Ã/g, 'U'], [/Ã/g, 'N']
];

for (const p of [APP_ASSETS, APP_COVERS, APP_AUDIO, APP_DATA, APP_PUBLIC, APP_PUBLIC_ASSETS, APP_PUBLIC_COVERS, APP_PUBLIC_AUDIO]) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

/**
 * Read and parse JSON file with error handling
 * @param {string} file - Path to JSON file
 * @returns {Array} Parsed array or empty array on error
 */
function readJson(file) {
  try { 
    return JSON.parse(fs.readFileSync(file, 'utf8') || '[]'); 
  } catch { 
    return []; 
  }
}

/**
 * Sanitize filename for Metro/Webpack compatibility
 * Removes accents, special characters, and fixes UTF-8 corruption
 * @param {string} name - Original filename
 * @returns {string} Sanitized filename safe for bundlers
 */
function sanitizeFilename(name) {
  let clean = name;
  for (const [pattern, replacement] of ENCODING_REPLACEMENTS) {
    clean = clean.replace(pattern, replacement);
  }
  
  return clean
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\s+/g, '_')
    .replace(/[^a-zA-Z0-9._-]/g, '')
    .replace(/_{2,}/g, '_');
}

/**
 * Main generation function
 * Copies assets, sanitizes filenames, and generates TypeScript maps
 * @returns {Promise<{covers: number, audios: number, tracks: number}>} Generation statistics
 */
export async function generate() {
  const albums = readJson(path.join(DATA_DIR, 'albums.json'));
  const tracks = readJson(path.join(DATA_DIR, 'tracks.json'));

  const coverFilenames = [...new Set(albums.filter(a => a.coverFilename).map(a => a.coverFilename))];
  const coverMapEntries = [];
  const coverRenameMap = {};
  
  for (const file of coverFilenames) {
    const src = path.join(COVERS_DIR, file);
    if (!fs.existsSync(src)) continue;
    
    const safeName = sanitizeFilename(file);
    const destAssets = path.join(APP_COVERS, safeName);
    const destPublic = path.join(APP_PUBLIC_COVERS, safeName);
    
    fs.copyFileSync(src, destAssets);
    fs.copyFileSync(src, destPublic);
    
    coverMapEntries.push(safeName);
    coverRenameMap[file] = safeName;
  }

  const audioFilenames = [...new Set(tracks.filter(t => t.audioFilename).map(t => t.audioFilename))];
  const audioMapEntries = [];
  const audioRenameMap = {};
  
  for (const file of audioFilenames) {
    const src = path.join(AUDIO_DIR, file);
    if (!fs.existsSync(src)) continue;
    
    const safeName = sanitizeFilename(file);
    const destAssets = path.join(APP_AUDIO, safeName);
    const destPublic = path.join(APP_PUBLIC_AUDIO, safeName);
    
    fs.copyFileSync(src, destAssets);
    fs.copyFileSync(src, destPublic);
    
    const track = tracks.find(t => t.audioFilename === file);
    if (track) {
      audioMapEntries.push({ id: track.id, safeName });
    }
    audioRenameMap[file] = safeName;
  }

  generateCoverMap(coverMapEntries);
  generateAudioMap(audioMapEntries);
  generateCoverByTrackMap(tracks, albums, coverRenameMap);
  generateLibrary(tracks, albums, coverRenameMap, audioRenameMap);

  return {
    covers: coverMapEntries.length,
    audios: audioMapEntries.length,
    tracks: tracks.length
  };
}

/**
 * Generate TypeScript map file for album covers
 * @param {string[]} coverMapEntries - Array of sanitized cover filenames
 */
function generateCoverMap(coverMapEntries) {
  const coversMapPath = path.join(APP_COVERS, 'map.ts');
  const coversMapContent = `// Generated by admin-panel/tools/generateAssets.mjs
export const coversMap: Record<string, string> = {
${coverMapEntries.map(f => `  '${f}': './${f}',`).join('\n')}
};
`;
  fs.writeFileSync(coversMapPath, coversMapContent, 'utf8');
}

/**
 * Generate TypeScript map file for audio tracks
 * @param {Array<{id: string, safeName: string}>} audioMapEntries - Array of track IDs and sanitized filenames
 */
function generateAudioMap(audioMapEntries) {
  const audioMapPath = path.join(APP_AUDIO, 'map.ts');
  const audioMapLines = audioMapEntries
    .filter(entry => entry.id)
    .map(entry => `  '${entry.id}': './${entry.safeName}',`);
  const audioMapContent = `// Generated by admin-panel/tools/generateAssets.mjs
export const audioMap: Record<string, string> = {
${audioMapLines.join('\n')}
};
`;
  fs.writeFileSync(audioMapPath, audioMapContent, 'utf8');
}

/**
 * Generate TypeScript map file for covers by trackId
 * @param {Array} tracks - All tracks from database
 * @param {Array} albums - All albums from database
 * @param {Object} coverRenameMap - Mapping of original to sanitized cover filenames
 */
function generateCoverByTrackMap(tracks, albums, coverRenameMap) {
  const coverMapPath = path.join(APP_COVERS, 'trackMap.ts');
  
  // Generar imports para todas las imágenes únicas
  const uniqueCovers = new Set();
  const coverMapEntries = tracks
    .map(t => {
      const album = albums.find(a => a.id === t.albumId);
      if (!album || !album.coverFilename) return null;
      const coverSafe = coverRenameMap[album.coverFilename];
      if (!coverSafe) return null;
      uniqueCovers.add(coverSafe);
      return { trackId: t.id, coverFile: coverSafe };
    })
    .filter(Boolean);
  
  // Generar imports para cada imagen única
  const importLines = Array.from(uniqueCovers).map(cover => {
    const varName = cover.replace(/[^a-zA-Z0-9]/g, '_');
    return `import cover_${varName} from './${cover}';`;
  }).join('\n');
  
  // Generar el mapeo usando las variables importadas
  const mapEntries = coverMapEntries.map(e => {
    const varName = e.coverFile.replace(/[^a-zA-Z0-9]/g, '_');
    return `  '${e.trackId}': cover_${varName},`;
  }).join('\n');
  
  const coverMapContent = `// Generated by admin-panel/tools/generateAssets.mjs
${importLines}

export const coverByTrackMap: Record<string, any> = {
${mapEntries}
};
`;
  fs.writeFileSync(coverMapPath, coverMapContent, 'utf8');
}

/**
 * Generate library.json with all tracks and associated album data
 * @param {Array} tracks - All tracks from database
 * @param {Array} albums - All albums from database
 * @param {Object} coverRenameMap - Mapping of original to sanitized cover filenames
 * @param {Object} audioRenameMap - Mapping of original to sanitized audio filenames
 */
function generateLibrary(tracks, albums, coverRenameMap, audioRenameMap) {
  const tracksOut = tracks.map(t => {
    const album = albums.find(a => a.id === t.albumId) || null;
    const coverOrig = album && album.coverFilename;
    const coverSafe = coverOrig && coverRenameMap[coverOrig] ? coverRenameMap[coverOrig] : coverOrig;
    const audioOrig = t.audioFilename;
    const audioSafe = audioOrig && audioRenameMap[audioOrig] ? audioRenameMap[audioOrig] : audioOrig;
    
    return {
      id: t.id,
      title: t.title,
      artist: t.artist,
      album: album ? album.title : null,
      genre: t.genre,
      audioUrl: audioSafe || '',
      imageUrl: coverSafe || null,
    };
  });
  
  const library = { items: tracksOut };
  const libraryPath = path.join(APP_DATA, 'library.json');
  fs.writeFileSync(libraryPath, JSON.stringify(library, null, 2), 'utf8');
}

if (process.argv[1] && process.argv[1].endsWith('generateAssets.mjs')) {
  generate()
    .then(r => process.exit(0))
    .catch(e => process.exit(1));
}
